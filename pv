#!/usr/bin/env python3
"""
  A small utility that does some of the things that the Rust uv utility does
  but in native python. In my case on raspberry pi I cannot get cargo to 
  install uv. It goes in the project root. 

  It's more useful for running things than for development. One can develop
  on a pc/laptop with the fancy tools and then deploy on an embedded computer
  with this.

  It obviously restricts the dependencies to just python which is useful
  on smaller devices. 

  It's VERY limited now but what the heck! 

  ----------

  Copyright (c) 2025 Timothy Norman Murphy <tnmurphy@gmail.com>

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the “Software”), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be included
  in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
  NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
  OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
  THE USE OR OTHER DEALINGS IN THE SOFTWARE.


"""
import argparse
import venv
import sys
import os
import subprocess
import re
import pathlib

from typing import Dict, Any, Union

def parse_toml(toml_str: str) -> Dict[str, Any]:
    """
    Parse a subset of TOML (enough for pyproject.toml) without external modules.
    Supports: tables, inline tables, strings, integers, floats, booleans, arrays.
    """
    def parse_value(s: str) -> Any:
        s = s.strip()
        if not s:
            return None
        # Boolean
        if s == 'true':
            return True
        if s == 'false':
            return False
        # Integer
        if re.fullmatch(r'-?\d+', s):
            return int(s)
        # Float
        if re.fullmatch(r'-?\d+\.\d+', s):
            return float(s)
        # String (basic and literal)
        if (s.startswith('"') and s.endswith('"')) or (s.startswith("'") and s.endswith("'")):
            return s[1:-1]
        # Array
        if s.startswith('[') and s.endswith(']'):
            items = [parse_value(x.strip()) for x in s[1:-1].split(',') if x.strip()]
            return items
        # Inline table
        if s.startswith('{') and s.endswith('}'):
            return parse_inline_table(s)
        return s  # fallback

    def parse_inline_table(s: str) -> Dict[str, Any]:
        s = s.strip()[1:-1]
        table = {}
        for pair in re.findall(r'(\w+)\s*=\s*([^,]+)', s):
            key, val = pair
            table[key] = parse_value(val)
        return table

    def parse_table(line: str) -> Dict[str, Any]:
        match = re.fullmatch(r'\[([^\]]+)\]', line)
        if not match:
            return {}
        table_name = match.group(1)
        return {table_name: {}}

    result = {}
    current_table = None
    for line in toml_str.splitlines():
        line = line.strip()
        if not line or line.startswith('#'):
            continue
        if line.startswith('['):
            table = parse_table(line)
            if table:
                table_name = next(iter(table))
                result[table_name] = {}
                current_table = table_name
        elif '=' in line:
            if current_table is None:
                continue
            key, val = line.split('=', 1)
            key = key.strip()
            val = parse_value(val)
            result[current_table][key] = val
    return result

# Example usage:




dep_parse_re = re.compile("^([^=<> ]+)([=<> ]+.*)?$")

def strip_dep(dep: str):
    dm = dep_parse_re.match(dep)
    if dm:
        stripped_dep = dm.groups()[0]
    else: # ??? well, add the unsplit one in hope
        stripped_dep = dep
    return stripped_dep

def strip_deps(deps: list[str]):
    return [strip_dep(d) for d in deps]

            


class Project:
    def _read_project_with_official_toml(self, filename):
        try:
            with open(filename, "r") as tf:
                proj = toml.load(tf)['project']
        except FileNotFoundError:
            print(f"Error: {filename} not found.")
            sys.exit(1)
        except KeyError as e:
            print(f"Error: Missing required key in {filename}: {e}")
        return proj

    def _read_project_with_internal_toml(self, filename):
        try:
            with open(filename, "r") as tf:
                toml_content = tf.read()
                parsed = parse_toml(toml_content)
                return parsed ['project']
        except FileNotFoundError:
            print(f"Error: {filename} not found.")
            sys.exit(1)
        except KeyError as e:
            print(f"Error: Missing required key in {filename}: {e}")

    def _read_toml(self, filename="pyproject.toml"):
        try:
            global toml
            toml = __import__("toml")
            print(f"Using official toml parser")
            return self._read_project_with_official_toml(filename)
        except ImportError as e:
            print(f"Using builtin toml parser")
            return self._read_project_with_internal_toml(filename)

    def __init__(self, filename="pyproject.toml", venv_dir=".venv"):
        self.tomlfile = filename
        self.venv_dir = venv_dir
        proj = self._read_toml(filename)
        self.dependencies = proj['dependencies']
        self.name = proj['name']

    def venv(self):
        builder = venv.EnvBuilder(with_pip=True)
        builder.create(self.venv_dir)

    def install_dependencies(self):
        tmp_requirements = "requirements.txt"
        with open(tmp_requirements, "w") as rq:
            for d in self.dependencies:
                rq.write(f"{d}\n")
        print("pip: installing dependencies")
        subprocess.call(
            f"set -x; . {self.venv_dir}/bin/activate; pip install toml",
            shell=True,
            executable="/bin/bash"
        )
        subprocess.call(
            f"set -x; . {self.venv_dir}/bin/activate; pip install -r {tmp_requirements}",
            shell=True,
            executable="/bin/bash"
        )

    def whole_environment(self):
        if not os.path.exists(self.venv_dir):
            self.venv()
            self.install_dependencies()

    def run(self, args: str, working_dir: str='.'):
        self.whole_environment()
        os.chdir(working_dir)
        args_str = " ".join(args)
        print(f"running: {args_str}")
        subprocess.call(
            f"set -x; . {self.venv_dir}/bin/activate; echo \"python=$(which python)\"; {args_str}",
            shell=True,
            executable="/bin/bash"
        )

    def add_dependencies(self, newdeps: list[str]):
        """ adds a new dependency. wont' do anything if the dependency is already there
            even if it's an older version.
        """

        with open(self.tomlfile, "r") as f:
            data = toml.load(f)

        existing_deps = data['project']['dependencies']
        stripped_existing_deps = set(strip_deps(existing_deps))
        stripped_newdeps = strip_deps(newdeps)

        new_deps = []
        for nd in newdeps:
            snd = strip_dep(nd)
            if not snd in stripped_existing_deps:
                new_deps.append(nd)
            else:
                print(f"{snd} is already in {self.tomlfile}")
                return
        existing_deps.extend(new_deps)                
        with open(self.tomlfile, "w") as f:
            toml.dump(data, f)
        print(f"Added {new_deps} to {self.tomlfile}")

def main():
    parser = argparse.ArgumentParser(description="Manage your Python project.")
    parser.add_argument("command", choices=["run", "venv", "add", "sh"], help="Command to execute")
    parser.add_argument("args", nargs="*", help="additional arguments")
    args = parser.parse_args()

    p = Project()
    print(f"Project: {p.name}")

    if args.command == "run":
        if not args.args:
            print("Error: Please specify a script to run.")
            sys.exit(1)
       
        script  = pathlib.Path(args.args[0])

        p.run(["python3", script.name], working_dir = script.parent)
    if args.command == "sh":
        p.run(args.args)
    elif args.command == "venv":
        p.whole_environment()
    elif args.command == "add":
        if not args.args:
            print("Error: Please specify a dependency to add.")
            sys.exit(1)
        p.add_dependencies(args.args)

if __name__ == '__main__':
    main()

